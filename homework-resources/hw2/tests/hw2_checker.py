# CS104: Summer 2015
# Grading script for Homework 2
# Author: Aaron Cheney

# Run with the command: python hw2_checker.py
# Results will be placed in separate .txt files for each problem and will automatically
# open when the testing has been completed. 

# Options below:
# 0. Various information for valgrind and Google Tests. 
# 1. Toggle each problem on or off. 
# 2. Name individual executables and student source files.
# 3. Change file path for each executable, in case they are in subdirectories.
# 4. Use valgrind automatically on all executables. 
# 5. Use a makefile if it is provided, or use the commands here to compile each problem.
# 6. Customize the number of test files for each problem. 
# 7. Enter your prefered text editor. 

import sys, os

# 0.
# Different strings for compilation and execution commands.
# Do not edit.
valgrind = "valgrind --tool=memcheck --leak-check=yes"
gtest = "-I /usr/local/opt/gtest/include/ -l gtest -l gtest_main -pthread"
gtest_llistint = "gtest_llistint.cpp"
gtest_llistarray = "gtest_llistarray.cpp"
gtest_stack = "gtest_stack.cpp"

# 1.
# Set each entry to 0/1 to turn the tests off/on, so that tests can be run
# in isolation or alongside specific tests.
run_tests = [1, 1, 1, 1, 1]

# 2. 
# student_executables holds the names of the executables which will be created.
# student_source_files holds the .cpp files for problems 4 and 8 ONLY, since
# problems 5 through 7 will be tested with GTests. If the source files are located
# in a sub directory, include that path in their name. 
student_executables =  ['problem4', 'problem5', 'problem6', 'problem7', 'problem8']
student_source_files = ['../remdup.cpp',
						'../llistint.cpp ' + gtest_llistint,
						'../alistint.cpp ' + gtest_llistarray,
						'../stackint.cpp ../llistint.cpp ' + gtest_stack,
						'../laundry.cpp ../stackint.cpp ../llistint.cpp']

# 3.
# If the executables for problems 4 and 8 are located in another directory because
# of a student's makefile, include that path here. Do not include the name of the
# executable itself. 
executable_paths = ['./', './', './', './', './']

# 4.
# Toggle the valgrind option on/off.
use_valgrind = bool(0) # Change to bool(1) to run with valgrind.

# 5.
# Uncomment the line with the "make" command if the student has provided a makefile,
# or use the subsequent lines to compile the code. The individual compilation
# commands are in order for the problems, 4 through 8. 
# os.system("make")
if run_tests[0]:
    os.system("g++ -g -Wall " + student_source_files[0] + " -o " + student_executables[0])
if run_tests[1]:
    os.system("g++ -g -Wall " + student_source_files[1] + " " + gtest + " -o " + student_executables[1])
if run_tests[2]:
    os.system("g++ -g -Wall " + student_source_files[2] + " " + gtest + " -o " + student_executables[2])
if run_tests[3]:
    os.system("g++ -g -Wall " + student_source_files[3] + " " + gtest + " -o " + student_executables[3])
if run_tests[4]:
    os.system("g++ -g -Wall " + student_source_files[4] + " -o " + student_executables[4])

# 6. 
# The number of tests that will be run for each problem. To run the homework checker
# with a new test file, follow the established naming-convention and update the 
# list entry below. The integers indicate the number of test files that exist with
# the given naming convention for problems 4 and 8, respectively. The middle 0's
# are for the Google Test problems. 
number_of_tests = [7, 0, 0, 0, 6]

# 7. 
# Change your prefered text editor, and the results files will automatically be opened.
text_editor = "subl" # Or subl, gedit, etc.

# Lists for all of the files used in grading.
#
# The names of the files where the results for each problem will be placed. By default,
# they will be named results4.txt, results5.txt, results6.txt, ...
results = []

# The names of the input files used for testing. They are named: 
# Problem 4: duplicates1.in, duplicates2.in, ...
# Problem 8: laundry1.in, laundry2.in, ...
input_files = []

# The names of the output files generated by the student's code. They are named:
# Problem 4: student_duplicates1.out, student_duplicates2.out, ...
# Problem 8: student_laundry1.out, student_laundry2.out, ...
output_files = []

# The names of the files which contain the correct outputs for each problem. 
# They are named:
# Problem 4: duplicates1.out, duplicates2.out, ...
# Problem 8: laundry1.out, laundry2.out, ...
solution_files = []

# Populates the above lists with the properly named files. 
for i in range(0, len(number_of_tests)):
    results.append('results%d.txt' % (i + 4))   # Generates the results files. 
    input_files.append([])
    output_files.append([])
    solution_files.append([])
    for j in range(0, number_of_tests[i]):
        # Creates filenames for problem 4.
        if i == 0:
            input_files[i].append('duplicates%d.in' % (j + 1))
            output_files[i].append('student_duplicates%d.out' % (j + 1))
            solution_files[i].append('duplicates%d.out' % (j + 1))
        # Creates filenames for problem 8. 
        elif i == 4:
            input_files[i].append('laundry%d.in' % (j + 1))
            output_files[i].append('student_laundry%d.out' % (j + 1))
            solution_files[i].append('laundry%d.out' % (j + 1))

# Runs the code for all problems and all test cases using the students executable, 
# with valgrind as an option.
if use_valgrind:
    for i in range(0, len(number_of_tests)):
        if (i == 0 or i == 4) and (run_tests[i]):
            for j in range(0, number_of_tests[i]):
                os.system(valgrind + " " + executable_paths[i] + student_executables[i] + " " + input_files[i][j] + " " + output_files[i][j])
        elif run_tests[i]:
            os.system(valgrind + " " + "./" + student_executables[i] + " > " + results[i])
else: 
    for i in range(0, len(number_of_tests)):
        if (i == 0 or i == 4) and (run_tests[i]):
            for j in range(0, number_of_tests[i]):
                os.system(executable_paths[i] + student_executables[i] + " " + input_files[i][j] + " " + output_files[i][j])
        elif run_tests[i]:
            os.system("./" + student_executables[i] + " > " + results[i])

# Runs the tests for each test file. Only problems 4 and 8 are tested in this way. 
for i in range(0, len(number_of_tests)):
    if number_of_tests[i] != 0 and run_tests[i]:
        test_count = 0
        result_file = open(results[i], "w")
        result_file.write("Running tests for problem %d:\n\n" % (i + 4))
        for j in range(0, number_of_tests[i]):
            with open(solution_files[i][j], "r") as truthfile:
                data_truth = truthfile.read().strip()
            with open(output_files[i][j], "r") as testfile:
                data_test = testfile.read().strip()

            result_file.write("***Test Case " + input_files[i][j] + " ***\n\n")
            result_file.write("Student's Output:\n")
            result_file.write(data_test)
            result_file.write("\n------------------\n")
            result_file.write("Correct Solution:\n")
            result_file.write(data_truth)
            result_file.write("\n------------------\n")

            if data_truth == data_test:
                result_file.write("Match Found. Test PASSED\n\n")
            else:
                result_file.write("Match Failed. Test FAILED\n\n")
                test_count = test_count + 1
        result_file.write(" ")

        if test_count == 0:
            result_file.write("\nPASSED ALL TESTS")
        else:
            result_file.write("\nFAILED " + str(test_count) + " out of " + str(number_of_tests[i]) + " TESTS")
            result_file.write("\nMay require manual check of the output.")

        result_file.close()

# Cleans up the directory by removing the student generated text files. 
if run_tests[0]: 
    for i in range(0, number_of_tests[0]):
        os.system("rm student_duplicates%d.out" % (i + 1))

if run_tests[4]:
    for i in range(0, number_of_tests[4]):
        os.system("rm student_laundry%d.out" % (i + 1))

# Automatically opens the result files for fast viewing. 
for i in range(4, 9):
    if run_tests[i - 4]:
        os.system(text_editor + " results%s.txt" % i)
