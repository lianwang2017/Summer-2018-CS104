# CS104 Summer 2018: Homework 8 Grading Script
# Run with the command: python hw8_checker.py

import sys
import os
import re
sys.path.insert(0, '/')		# Adds the current directory to the system path so that the cs_grading
import cs_grading as CS 	# library of functions can be imported here. 

# General script information. Used to change which text editor you would like to use, whether or not to 
# run valgrind on the student's code, and whether to run specific tests. 
text_editor = 'subl -n'			# Change to your preferred text editor. 
automatically_open_files = 1	# Change to 0 to turn of automatic opening of result files. 

if len(sys.argv) < 5: 
	run_heap_test = 1				# Change to 0 to leave the heap test out of a run.
	run_trending = 1 				# Change to 0 to leave the trending test out of a run.
	run_hash_test = 1 				# Change to 0 to leave the hash test out of a run.
	run_user_n_passwords = 1  		# Change to 0 to leave the usr passwords test out of a run.
	run_splay_tree_test = 1 		# Change to 0 to leave the splay tree test out of a run. 
	automatically_open_files = 1 	# Change to 0 to turn of automatic opening of result files. 
else:
	for i in range(0,len(sys.argv)):
		run_heap_test = int(sys.argv[1])
		run_trending = int(sys.argv[2])
		run_hash_test = int(sys.argv[3])
		run_user_n_passwords = int(sys.argv[4])
		run_splay_tree_test = int(sys.argv[5])

'''
	HEAP TEST
'''
# Information for testing heap.
heap_file = '../heap.h'
heap_executable = 'heap_test'								# Name of executable generated by compilation 
heap_source_files = '-std=c++11 heap_gtest.cpp'				# .cpp files needed for GTest compilation
heap_result_file = 'heap_results.txt'						# File where results are placed. 
heap_gtest_flags = '--gtest_filter=**'						# Filters for running specific tests. 

# Running test for heap. 
if run_heap_test:
	CS.compile_student_code(0, source_files = heap_source_files, target = heap_executable, use_gtest = 1)
	CS.run_executable('./', heap_executable, heap_gtest_flags + ' > ' + heap_result_file, 0)
	if 'priority_queue' or 'make_heap' or 'push_heap' in open(heap_file).read():
		os.system("echo \"\nFOUND STL that shouldn't be used!!\" >> heap_result_file")
	elif '<algorithm>' in open(heap_file):
		os.system("echo \"\nFOUND <algorithm>, check if linear search was used \" >> heap_result_file")
	# end-tab
	if automatically_open_files:
		CS.open_file(heap_result_file, text_editor)
	# end-tab
# end-tab

'''
	HASH TEST
'''
# Running test for hash.
hash_executable = 'hash_test'									# Name of executable generated by compilation
hash_source_files = 'hash_gtest.cpp ../hash.o sol_hash.o'		# .cpp files needed for GTest compilation
hash_result_file = 'hash_results.txt'							# File where results are placed. 
hash_gtest_flags = ''
hash_valgrind_file = 'hash_valgrind.txt'

curr_dir = os.getcwd().strip().split('/')[-1]
os.chdir("../")
os.system("g++ -g -Wall -c -std=c++11 hash.cpp -o hash.o")
os.chdir(str(curr_dir))

if run_hash_test:
	CS.compile_student_code(0, source_files = hash_source_files, target = hash_executable, use_gtest = 1)
	CS.run_executable('./', hash_executable, hash_gtest_flags + ' > ' + hash_result_file, 1, hash_valgrind_file)
	if automatically_open_files:
		CS.open_file(hash_valgrind_file + ' ' + hash_result_file, text_editor)
	# end-tab
# end-tab

'''
	HASHTAGS TEST
'''
def remove_console(file_name):
	with open(file_name, 'r') as file:
		content = file.readlines();
		start_flag = 0
		end_flag = 0
		data = []
		for cont in content:
			if '======' in cont and start_flag == 1:
				end_flag = 1
			if "======" in cont and end_flag == 0:
				start_flag = 1
			if start_flag == 0 or end_flag == 1:
				data.append(cont.strip())
			# end-tab
		# end-tab
		output = open(file_name, 'w')
		for d in data:
			output.write(d + '\n')
		# end-tab
	# end-tab
# end-tab


def fix_order_trending(file_name):
	with open(file_name,'r') as file:
		content = file.readlines()
		pre_flag = 1
		pre_cont = []
		trending = []
		post_cont = []
		p = re.compile(r'\d+')
		for line in content:
			# checks if the current line is a trending line
			if(len(line.strip().split(':')) == 2 and p.findall(line.strip().split(':')[1]) == 1):
				pre_flag = 0
				trending.append([ line.strip().split(':')[0], line.strip().split(':')[1]] )
			elif(pre_flag):
				pre_cont.append(line.strip())
			else:
				post_cont.append(line.strip())
			# end-tab
		# end-tab 
		trending.sort(key=lambda x: (x[0], x[1]))
	output_file = open(file_name,'w')
	for line in pre_cont:
		output_file.write(line + '\n')
	for trending_pair in trending:
		output_file.write(trending_pair[0] + ' : ' + trending_pair[1] + '\n')
	for line in post_cont:
		output_file.write(line + '\n')
	# end-tab
# end-tab

# Running test for hashtags.
if run_trending:
	#######################
	##### Definitions #####
	#######################
	# Executables
	STUDENT_EXE = 'twitter'
	SOLUTION_EXE = 'sol_twitter'
	# Principal Data
	DATABASES = [ 	'twitterTrend1',
					'twitterVeryLargePwd'
	]
	DATA_SUFFIX = '.dat'
	OUTPUT_SUFFIX = '.out'
	# for running a specific command and then quiting
	COMMAND = 'TRENDING'
	COMMAND_PARAMS = [	'01',
						'03',
						'05',
						'10'
	]
	COMMAND_RUNS = [ '01',
					 '02'
	]
	COMMAND_SUFFIX = '.cmd'
	COMMAND_PARAM_PREFIX = '_N='
	COMMAND_RUN_PREFIX = '_R='
	# output directories and files
	STUDENT_OUTPUT_DIR = 'student_trending/'
	SOLUTION_OUTPUT_DIR = 'solution_trending/'
	RESULT_OUTPUT_DIR = 'result_trending/'
	VALGRIND_OUTPUT_DIR = 'valgrind_trending/'
	STUDENT_OUTFILE_PREFIX = 'trending_'
	SOLUTION_OUTFILE_PREFIX = 'sol_trending_'
	RESULT_OUTFILE_PREFIX = 'result_trending_'
	VALGRIND_OUTFILE_PREFIX = 'valgrind_trending_'

	################################
	##### Compile student code #####
	################################
	curr_dir = os.getcwd().strip().split('/')[-1]
	# Generate student twitter executable
	os.chdir('..')
	# print(os.getcwd())
	os.system('make clean')
	os.system('make')
	os.chdir(str(curr_dir))
	os.system(
		'rm -rf ' 
		+ STUDENT_OUTPUT_DIR + ' ' 
		+ SOLUTION_OUTPUT_DIR + ' ' 
		+ RESULT_OUTPUT_DIR + ' ' 
		+ VALGRIND_OUTPUT_DIR
	)
	os.system(
		'mkdir ' 
		+ STUDENT_OUTPUT_DIR + ' ' 
		+ SOLUTION_OUTPUT_DIR + ' ' 
		+ RESULT_OUTPUT_DIR + ' ' 
		+ VALGRIND_OUTPUT_DIR
	)
	# Generate output files from student twitter and solution twitter
	for i in range(0, len(DATABASES)):
		for j in range(0, len(COMMAND_PARAMS)):
			for k in range(0, len(COMMAND_RUNS)):
				os.system('rm -f ' + COMMAND + COMMAND_SUFFIX)
				os.system('touch ' + COMMAND + COMMAND_SUFFIX)
				if 'w' in COMMAND_RUNS[k]:
					print("IN 100 CASE")
					if('Trend' in DATABASES[i]):
						os.system('echo LOGIN Aaron abc123 >> ' + COMMAND + COMMAND_SUFFIX)
					else:
						os.system('echo LOGIN user1 curious >> ' + COMMAND + COMMAND_SUFFIX)
					# end-tab
					for l in range(0,100):
						os.system('echo TWEET #newtrending tweets >> ' + COMMAND + COMMAND_SUFFIX)
					# end-tab
				else: 
					for val in range(0,int(COMMAND_RUNS[k])):
						os.system('echo ' + COMMAND + ' ' + COMMAND_PARAMS[j] 
							+ ' >> ' + COMMAND + '.cmd'
						)
					# end-tab
				# end-tab
				os.system('echo QUIT >> ' + COMMAND + COMMAND_SUFFIX)
				CS.run_executable('../', 
					STUDENT_EXE, 
					DATABASES[i] + DATA_SUFFIX + ' < ' + COMMAND + COMMAND_SUFFIX +
					' > ' + STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX,
					1, 
					VALGRIND_OUTPUT_DIR + VALGRIND_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + '.txt' 
				)
				
				fix_order_trending(STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX)
				remove_console(STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX)
				CS.run_executable('./', 
					SOLUTION_EXE, 
					DATABASES[i] + DATA_SUFFIX + ' < ' + COMMAND + COMMAND_SUFFIX +
					' > ' + SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX
				)
				fix_order_trending(SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX)
				remove_console(SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX)
			# end-tab
		# end-tab
	# end-tab

	# clean up unnecessary files 
	os.system('rm -f *.feed *.mentions')
	# Iterates through all databases and commands mentioned. 
	for i in range(0, len(DATABASES)):
		for j in range(0, len(COMMAND_PARAMS)):
			for k in range(0, len(COMMAND_RUNS)):
				results_file = RESULT_OUTPUT_DIR + RESULT_OUTFILE_PREFIX + DATABASES[i] + COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + '.txt'
				# Compares the solution's files to the student's files and prints the results to its own section. 
				CS.write_header(results_file)
				CS.write_message(results_file, '\nCOMPARING TRENDING FILES:\n\n')

				errors = CS.compare_files_with_order(
					SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX, 
					STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + DATABASES[i] 
					+ COMMAND_PARAM_PREFIX + COMMAND_PARAMS[j] + COMMAND_RUN_PREFIX + COMMAND_RUNS[k] + OUTPUT_SUFFIX,
					results_file,
					ignore_lines_with = '..........'
					)

				if errors[1] == 0 and errors[2] == 0:
					CS.write_message(results_file, '\n\nPASSED TEST')
				else:
					CS.write_message(results_file, '\n\nFAILED TEST')
				# end-tab

				message = '\n\nThere were ' + str(errors[1]) + ' missing lines and ' + str(errors[2]) + ' extra lines.\n'
				CS.write_message(results_file, message)
				CS.write_footer(results_file)
			# end-tab
		# end-tab
	# end-tab

	if automatically_open_files:
		os.system('subl -n ' + RESULT_OUTPUT_DIR + ' ' 
			+ STUDENT_OUTPUT_DIR + ' ' 
			+ SOLUTION_OUTPUT_DIR + ' ' 
			+ RESULT_OUTPUT_DIR + RESULT_OUTFILE_PREFIX + '*'
		)
	# end-tab
# end-tab

'''
	USERS AND PASSWORDS TEST
'''
# Running test for users and passwords.
if run_user_n_passwords:
	#######################
	##### Definitions #####
	#######################

	# Executables
	STUDENT_EXE = 'twitter'
	SOLUTION_EXE = 'sol_twitter'
	KEY_WORD = 'usr_n_pwds'
	COMMAND_DIR = 'usr_n_pwds_tests'

	# Principal Data
	DATABASE = 'twitterTrend1'
	DATA_SUFFIX = '.dat'
	OUTPUT_SUFFIX = '.out'
	COMMAND_SUFFIX = '.cmd'
	COMMANDS = []
	COMMAND_NAMES = []
	for file in os.listdir('./' + COMMAND_DIR):
		COMMANDS.append('./' + COMMAND_DIR + '/' + file)
		COMMAND_NAMES.append(file.split('.')[0])
	# end-tab

	# output directories and files
	STUDENT_OUTPUT_DIR = 'student_' + KEY_WORD + '/'
	SOLUTION_OUTPUT_DIR = 'solution_' + KEY_WORD + '/'
	RESULT_OUTPUT_DIR = 'result_' + KEY_WORD + '/'
	VALGRIND_OUTPUT_DIR = 'valgrind_' + KEY_WORD + '/'
	STUDENT_OUTFILE_PREFIX = 'student_' + KEY_WORD + '_'
	SOLUTION_OUTFILE_PREFIX = 'sol_' + KEY_WORD + '_'
	RESULT_OUTFILE_PREFIX = 'result_' + KEY_WORD + '_'
	VALGRIND_OUTFILE_PREFIX = 'valgrind_' + KEY_WORD + '_'

	################################
	##### Compile student code #####
	################################
	curr_dir = os.getcwd().strip().split('/')[-1]
	# Generate student twitter executable
	os.chdir('..')
	# print(os.getcwd())
	os.system('make clean')
	os.system('make')
	os.chdir(str(curr_dir))
	os.system(
		'rm -rf ' 
		+ STUDENT_OUTPUT_DIR + ' ' 
		+ SOLUTION_OUTPUT_DIR + ' ' 
		+ RESULT_OUTPUT_DIR + ' ' 
		+ VALGRIND_OUTPUT_DIR
	)
	os.system(
		'mkdir ' 
		+ STUDENT_OUTPUT_DIR + ' ' 
		+ SOLUTION_OUTPUT_DIR + ' ' 
		+ RESULT_OUTPUT_DIR + ' ' 
		+ VALGRIND_OUTPUT_DIR
	)
	# Generate output files from student twitter and solution twitter
	for i in range(0, len(COMMANDS)):
		results_file = RESULT_OUTPUT_DIR + RESULT_OUTFILE_PREFIX + COMMAND_NAMES[i] + '.txt'
		student_file = STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX
		solution_file = SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX

		print(COMMANDS[i])
		CS.run_executable('../', 
			STUDENT_EXE, 
			DATABASE + DATA_SUFFIX + ' < ' + COMMANDS[i] +
			' > ' + STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX,
			1, 
			VALGRIND_OUTPUT_DIR + VALGRIND_OUTFILE_PREFIX + COMMAND_NAMES[i] + '.txt'
		)
		remove_console(STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX)
		os.system('rm -f *.feeds *.mentions')
		CS.run_executable('./', 
			SOLUTION_EXE, 
			DATABASE + DATA_SUFFIX + ' < ' + COMMANDS[i] +
			' > ' + SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX
		)
		remove_console(SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX)
		os.system('rm -f *.feeds *.mentions')

		CS.write_header(results_file)
		CS.write_message(results_file, '\nCOMPARING USR_N_PWD FILES:\n\n')
		errors = CS.compare_files_with_order(
			SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX, 
			STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX,
			results_file,
			ignore_lines_with = '...........'
		)
		if errors[1] == 0 and errors[2] == 0:
				CS.write_message(results_file, '\n\nPASSED CONSOLE TEST')
		else:
				CS.write_message(results_file, '\n\nFAILED CONSOLE TEST')
		# end-tab

		message = '\n\nThere were ' + str(errors[1]) + ' missing lines and ' + str(errors[2]) + ' extra lines.\n'
		CS.write_message(results_file, message)

		CS.run_executable('../', 
			STUDENT_EXE, 
			DATABASE + DATA_SUFFIX + ' < ' + COMMANDS[i] +
			' > ' + STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX,
			1, 
			VALGRIND_OUTPUT_DIR + VALGRIND_OUTFILE_PREFIX + COMMAND_NAMES[i] + '.txt'
		)
		remove_console(STUDENT_OUTPUT_DIR + STUDENT_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX)
		print("ONTO TO FEEDS")
		os.system('cp Aaron.feed Student_Aaron.out')
		CS.write_message(student_file, '\n\n')
		CS.write_message(student_file, 'Aaron.feed:\n')
		CS.write_file_contents(student_file, 'Aaron.feed')
		os.system('rm -f *.feed *.mentions')

		CS.run_executable('./', 
			SOLUTION_EXE, 
			DATABASE + DATA_SUFFIX + ' < ' + COMMANDS[i] +
			' > ' + SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX
		)
		remove_console(SOLUTION_OUTPUT_DIR + SOLUTION_OUTFILE_PREFIX + COMMAND_NAMES[i] + OUTPUT_SUFFIX)
		CS.write_message(solution_file, '\n\n')
		CS.write_message(solution_file, 'Aaron.feed:\n')
		CS.write_file_contents(solution_file, 'Aaron.feed')

		errors2 = CS.compare_files_with_order(
			'Aaron.feed', 
			'Student_Aaron.out',
			results_file,
			ignore_lines_with = '...........'
		)
		if errors2[1] == 0 and errors2[2] == 0:
				CS.write_message(results_file, '\n\nPASSED FEED TEST')
		else:
				CS.write_message(results_file, '\n\nFAILED FEED TEST')
		# end-tab
		with open(results_file, 'r') as original: data = original.read()
		with open(results_file, 'w') as modified:
			if errors2[1] == 0 and errors2[2] == 0 and errors[1] == 0 and errors[2] == 0:
				modified.write('PASSED BOTH CONSOLE AND FEED \n' + data)
			elif errors[1] == 0 and errors[2] == 0:
				modified.write('PASSED CONSOLE AND FAILED FEED \n' + data)
			elif errors2[1] == 0 and errors2[2] == 0:
				modified.write('FAILED CONSOLE AND PASSED FEED \n' + data)
			else:
				modified.write('FAILED CONSOLE AND FAILED FEED \n' + data)
			# end-tab
		# end-tab
		os.system('rm -f Student_Aaron.out *.feed *.mentions')

	# end-tab
	if automatically_open_files:
		os.system('subl -n ' + RESULT_OUTPUT_DIR 
			+ ' ' + STUDENT_OUTPUT_DIR + ' ' 
			+ SOLUTION_OUTPUT_DIR + ' ' 
			+ RESULT_OUTPUT_DIR + RESULT_OUTFILE_PREFIX + '*'
		)
	# end-tab
# end-tab


# Information for testing splay tree.
splay_tree_executable = 'splay_tree_test'
splay_tree_source_files = 'splay_tree_gtest.cpp'
splay_tree_result_file = 'splay_tree_results.txt'
splay_tree_gtest_flags = '--gtest_filter=**'
splay_tree_valgrind_file = 'splay_tree_valgrind.txt'

'''
	SPLAY TEST
'''
# Running test for splay tree
if run_splay_tree_test:
	CS.compile_student_code(0, source_files = splay_tree_source_files, target = splay_tree_executable, use_gtest = 1)
	CS.run_executable('./', splay_tree_executable, splay_tree_gtest_flags + ' > ' + splay_tree_result_file, 1, splay_tree_valgrind_file)
	if automatically_open_files:
		CS.open_file(splay_tree_valgrind_file + ' ' + splay_tree_results, text_editor)
	# end-tab
# end-tab

# Cleaning up the directory
if(os.path.isfile(os.getcwd()+heap_executable)):
	CS.remove_file(heap_executable)
if(os.path.isfile(os.getcwd()+splay_tree_executable)):
	CS.remove_file(splay_tree_executable)