# CS104: Summer 2015
# Grading script for Homework 1
# Author: Aaron Cheney

# Run with the command: python hw1_checker.py
# Results will be placed in separate .txt files for each problem.

# Options below:
# 1. Name individual executables and student source files.
# 2. Change file path for each executable, in case they are in subdirectories.
# 3. Use valgrind automatically on all executables. 
# 4. Use a makefile if it is provided, or use the commands here to compile each problem.
# 5. Customize the number of test files for each problem. 

import sys, os

#1. 
# Rename these variables with the executable for problems 4, 5, and 6, respectively. 
# Rename the source files if students have different names for their .cpp files. 
student_executables = ['problem4', 'problem5', 'problem6']
student_source_files = ['../string.cpp', '../twitter.cpp', '../sentences.cpp']

# 2.
# If the executables are located in different directories, name them here. Do not
# include the name of the executable itself. 
executable_paths = ['./', './', './']

# 3.
# Information for running code with valgrind. 
valgrind = "valgrind --tool=memcheck --leak-check=yes "
use_valgrind = bool(0) # Change to bool(1) to run with valgrind.

# 4.
# Uncomment if a makefile is provided by the student, or use one of the lines below to compile.
# os.system("make")
os.system("g++ -g -Wall " + student_source_files[0] + " -o " + student_executables[0])
os.system("g++ -g -Wall " + student_source_files[1] + " -o " + student_executables[1])
os.system("g++ -g -Wall " + student_source_files[2] + " -o " + student_executables[2])

# 5. 
# The number of tests that will be run for each problem. To run the homework checker
# with a new test file, follow the established naming-convention and update the 
# list entry below. The integers indicate the number of test files that exist with
# the given naming convention for problems 4, 5, and 6, respectively. 
number_of_tests = [5, 3, 3]

# Lists for all of the files used in grading.
#
# The names of the files where the results for each problem will be placed. By default,
# they will be named results1.txt, results2.txt, and results3.txt.
results = []

# The names of the input files used for testing. They are named: 
# Problem 4: sum_pairs1.in, sum_pairs2.in, ...
# Problem 5: tweets1.in, tweets2.in, ...
# Problem 6: sentences1.in, sentences2.in, ...
input_files = []

# The names of the output files generated by the student's code. They are named:
# Problem 4: student_sum1.out, student_sum2.out, ...
# Problem 5: student_tweets1.out, student_tweets2.out, ...
# Problem 6: student_sentences1.out, student_sentences2.out, ...
output_files = []

# The names of the files which contain the correct outputs for each problem. They are named:
# Problem 4: sum_pairs1.out, sum_pairs2.out, ...
# Problem 5: tweets1.out, tweets2.out, ...
# Problem 6: sentences1.out, sentences2.out, ...
solution_files = []

# Populates the above lists with the properly named files. 
for i in range(0, len(number_of_tests)):
    results.append('results%d.txt' % (i + 1))	# Generates the results files. 
    input_files.append([])
    output_files.append([])
    solution_files.append([])
    for j in range(0, number_of_tests[i]):
    	# Creates filenames for problem 4.
        if i == 0:
            input_files[i].append('sum_pairs%d.in' % (j + 1))
            output_files[i].append('student_sum%d.out' % (j + 1))
            solution_files[i].append('sum_pairs%d.out' % (j + 1))
        # Creates filenames for problem 5. 
        elif i == 1:
            input_files[i].append('tweets%d.in' % (j + 1))
            output_files[i].append('student_tweets%d.out' % (j + 1))
            solution_files[i].append('tweets%d.out' % (j + 1))
        # Creates filenames for problem 6. 
        elif i == 2:
            input_files[i].append('sentences%d.in' % (j + 1))
            output_files[i].append('student_sentences%d.out' % (j + 1))
            solution_files[i].append('sentences%d.out' % (j + 1))

# Runs the code for all problems and all test cases using the students executable, 
# with valgrind as an option.
if use_valgrind:
    for i in range(0, len(number_of_tests)):
        for j in range(0, number_of_tests[i]):
            if i == 0 or i == 2:
                os.system(valgrind + executable_paths[i] + student_executables[i] + " " + input_files[i][j] + " " + output_files[i][j])
            elif i == 1:
                os.system(valgrind + executable_paths[i] + student_executables[i] + " " + input_files[i][j] + " > " + output_files[i][j])
else: 
    for i in range(0, len(number_of_tests)):
        for j in range(0, number_of_tests[i]):
            if i == 0 or i == 2:
                os.system(executable_paths[i] + student_executables[i] + " " + input_files[i][j] + " " + output_files[i][j])
            elif i == 1:
                os.system(executable_paths[i] + student_executables[i] + " " + input_files[i][j] + " > " + output_files[i][j])

# Compares the student's output with the expected output in the solution files. 
# The results are printed in a separate file for each problem. 
for i in range(0, len(number_of_tests)): 
    test_count = 0
    result_file = open(results[i], "w")
    result_file.write("Running tests for problem %d:\n\n" % (i + 4))
    for j in range(0, number_of_tests[i]):
        with open(solution_files[i][j], "r") as truthfile:
            data_truth = truthfile.read().strip()
        with open(output_files[i][j], "r") as testfile:
            data_test = testfile.read().strip()

        # Specific code to test whether or not the student has generated all of the 
        # correct sentences regardless of their order. Sentences will be marked
        # as "MISSING", "FOUND", or "EXTRA".
        if i == 2:
            result_file.write("***Test Case " + input_files[i][j] + " ***\n\n")

            testfile = open(output_files[i][j], "r")
            truthfile = open(solution_files[i][j], "r")

            # Students responses are stored in a set so that their order is independent. 
            test_set = set()
            sentence_list = []
            line_test = testfile.readline().strip()
            while line_test:
                sentence_list.append(line_test)
                line_test = testfile.readline().strip()

            for n in range(0, len(sentence_list) - 1):
                test_set.add(sentence_list[n])
            
            total_sentences = len(test_set)

            result_file.write("Student's Sentences:\n")
            missing_sentences = 0
            true_sentence_list = []
            line_truth = truthfile.readline().strip()
            while line_truth:
                true_sentence_list.append(line_truth)
                line_truth = truthfile.readline().strip()

            # Checks that all of the sentences that should be generated are 
            # in the student's solutions, in any order. If so, then it is
            # removed from the set, otherwise the number of missing sentences
            # is incremented and shown in the result file. 
            for n in range(0, len(true_sentence_list) - 1):
                if true_sentence_list[n] in test_set:
                    result_file.write("FOUND: " + true_sentence_list[n] + "\n")
                    test_set.remove(true_sentence_list[n])
                elif true_sentence_list[n] not in test_set:
                    result_file.write("MISSING: " + true_sentence_list[n] + "\n")
                    missing_sentences += 1

            extra_sentences = bool(len(test_set))

            # Checks for extra sentences that the student may have generated. 
            while len(test_set):
                result_file.write("EXTRA: " + test_set.pop() + "\n")

            # Writes the last line in the file, which should contain the number
            # of sentences as per the assignment instructions.
            try:
                result_file.write("LAST LINE: " + sentence_list[-1] + "\n")
            except IndexError:
                result_file.write("[NO SENTENCES GENERATED]\n")

            result_file.write("\n------------------\n")
            result_file.write("Correct Solution:\n")
            result_file.write(data_truth)
            result_file.write("\n------------------\n")

            # Prints the results of checking the tests. The four cases cover all 
            # possibilities for student outputs. 
            if (missing_sentences == 0) and (not extra_sentences):
                result_file.write("TEST PASSED\n")
                result_file.write("All valid sentences found and no extra sentences were generated.\n\n")
            elif (missing_sentences != 0) and (not extra_sentences):
                result_file.write("TEST FAILED\n")
                result_file.write("Missing " + str(missing_sentences) + " sentences of " + str(total_sentences) + " total.\n\n")
                test_count += 1
            elif (missing_sentences == 0) and (extra_sentences):
                result_file.write("TEST FAILED\n")
                result_file.write("All valid sentences found, but extra sentences were generated.\n\n")
                test_count += 1
            else:
                result_file.write("TEST FAILED\n")
                result_file.write("Missing " + str(missing_sentences) + " sentences of " + str(total_sentences) + " total.\n")
                result_file.write("Extra sentences were also generated.\n\n")
                test_count += 1
        elif i == 0 or i == 1:
            result_file.write("***Test Case " + input_files[i][j] + " ***\n\n")
            result_file.write("Student's Output:\n")
            result_file.write(data_test)
            result_file.write("\n------------------\n")
            result_file.write("Correct Solution:\n")
            result_file.write(data_truth)
            result_file.write("\n------------------\n")

            if data_truth == data_test:
                result_file.write("Match Found. Test PASSED\n\n")
            else:
                result_file.write("Match Failed. Test FAILED\n\n")
                test_count = test_count + 1

        truthfile.close()
        testfile.close()
        result_file.write(" ")

    if test_count == 0:
        result_file.write("\nPASSED ALL TESTS")
    else:
        result_file.write("\nFAILED " + str(test_count) + " out of " + str(number_of_tests[i]) + " TESTS")
        result_file.write("\nMay require manual check of the output.")

    result_file.close()

# Cleans up the directory. 
for i in range(0, number_of_tests[0]):
    os.system("rm student_sum%d.out" % (i + 1))

for i in range(0, number_of_tests[1]):
    os.system("rm student_tweets%d.out" % (i + 1))

for i in range(0, number_of_tests[2]):
    os.system("rm student_sentences%d.out" % (i + 1))
